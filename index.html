<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Micro:Bit Controller â€” Large UI (Integrated BLE)</title>
  <style>
    :root{
      --bg:#E84E0E;
      --white:#fff;
      --glass:rgba(255,255,255,0.06);
      --accent:rgba(255,255,255,0.12);
      --shadow:0 18px 60px rgba(0,0,0,0.25);
      --radius:22px;
      --gap:48px;
      --control-size:420px;   /* increased controller size */
      --arrow-size:110px;     /* arrow button size */
      --center-size:160px;    /* center mic size */
      --ctrl-gap:54px;
      --btn-h:56px;
      --font-sans:"Inter",system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;
    }

    .top-header {
      position: fixed;
      top: 80px;
      left: 80px;
      display: flex;
      align-items: center;
      z-index: 100;
    }

    .logo {
      height: 70px;
      width: auto;
      cursor: pointer;
      transition: transform 0.2s ease;
    }

    .logo:hover {
      transform: scale(1.05);
    }


    html,body{height:100%;margin:0;font-family:var(--font-sans);background:var(--bg);color:var(--white);-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;}
    .wrap{min-height:100%;display:flex;align-items:center;justify-content:center;padding:36px;box-sizing:border-box;}

    .app{
      width:1400px;max-width:96vw;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(0,0,0,0.02));
      border-radius:var(--radius);box-shadow:var(--shadow);padding:44px;display:flex;gap:var(--gap);align-items:stretch;overflow:hidden;
    }

    /* Left controller area */
    .panel-left{flex:1;min-width:520px;display:flex;align-items:center;justify-content:center;padding:28px;}
    .controller{
      width:var(--control-size);height:var(--control-size);
      display:grid;
      grid-template-rows: 1fr auto 1fr;
      grid-template-columns: 1fr auto 1fr;
      place-items:center;
      position:relative;
      gap:var(--ctrl-gap);
      padding-bottom: 70px;
    }

    .arrow-btn{
      width:var(--arrow-size);
      height:var(--arrow-size);
      border-radius:18px;
      background:var(--glass);
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      transition: transform .14s cubic-bezier(.2,.9,.3,1), box-shadow .14s, background .14s;
      user-select:none;
      box-shadow: 0 18px 40px rgba(0,0,0,0.2), inset 0 1px 0 rgba(255,255,255,0.02);
      border: 1px solid rgba(255,255,255,0.03);
      --icon-scale: 36px;
    }
    .arrow-btn .arrow-icon{ width:var(--icon-scale); height:var(--icon-scale); fill:#000; opacity:0.98; }
    .arrow-btn:active, .arrow-btn.pressed, .arrow-btn.active {
      transform: translateY(-8px) scale(1.03);
      box-shadow: 0 28px 60px rgba(0,0,0,0.32);
      /* keep smooth transition but override background/icon below */
    }

    /* When active/pressed make the whole button solid white and invert the icon to the accent (orange) */
    .arrow-btn.active, .arrow-btn.pressed {
      background: var(--white) !important;
      border-color: rgba(255,255,255,0.9);
    }
    .arrow-btn.active .arrow-icon, .arrow-btn.pressed .arrow-icon{
      fill: var(--bg) !important;
      opacity:1;
    }

    .up{grid-row:1;grid-column:2}
    .left{grid-row:2;grid-column:1}
    .right{grid-row:2;grid-column:3}
    .down{grid-row:3;grid-column:2}

    /* center mic button */
    .dot{
      grid-row:2;grid-column:2;
      width:var(--center-size);height:var(--center-size);
      border-radius:999px;background:var(--white);
      display:flex;align-items:center;justify-content:center;
      box-shadow: 0 20px 80px rgba(0,0,0,0.3);
      transform-origin:center;cursor:pointer;
    }
    .dot svg{width:56px;height:56px;fill:var(--bg)}
    .dot.listening{ box-shadow: 0 32px 110px rgba(0,0,0,0.42), 0 0 0 12px rgba(255,255,255,0.06); }
    .dot.listening::after{
      content:"";
      position:absolute;inset:-8px;border-radius:999px;border:2px solid rgba(255,255,255,0.22);
      animation:ping 1.2s cubic-bezier(.2,.9,.3,1) infinite;
    }
    @keyframes ping{0%{transform:scale(1);opacity:.7}100%{transform:scale(1.28);opacity:0}}

    .ripple{position:absolute;width:18px;height:18px;border-radius:999px;background:rgba(255,255,255,0.12);pointer-events:none;transform:scale(0);opacity:0;}

    /* Control mode buttons */
    .control-modes{
      display:flex;
      gap:12px;
      margin-bottom:20px;
      justify-content:center;
    }
    .mode-btn{
      background:var(--glass);
      color:var(--white);
      border:1px solid rgba(255,255,255,0.06);
      padding:12px 24px;
      border-radius:12px;
      cursor:pointer;
      font-weight:800;
      font-size:14px;
      transition:all .2s ease;
      user-select:none;
    }
    .mode-btn.active{
      background:var(--white);
      color:var(--bg);
      box-shadow:0 8px 24px rgba(0,0,0,0.15);
    }
    .mode-btn:hover:not(.active){
      background:rgba(255,255,255,0.08);
    }

    /* Right panel (controls) */
    .panel-right{
      width:520px; max-width:48%;
      padding:28px;
      display:flex;
      flex-direction:column;
      gap:20px;
      align-items:stretch;
    }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      padding:22px;
      border-radius:16px;
      border:1px solid rgba(255,255,255,0.03);
      box-shadow: 0 14px 40px rgba(0,0,0,0.12);
      display:flex;
      flex-direction:column;
      gap:16px;
    }

    .slider-row{display:flex;align-items:center;gap:18px;}
    .slider-label{width:110px;font-weight:800;font-size:14px;opacity:.98}
    input[type=range]{-webkit-appearance:none;appearance:none;height:8px;flex:1;background:transparent;outline:none;border-radius:8px;}
    input[type=range]::-webkit-slider-runnable-track{height:8px;background:linear-gradient(90deg,rgba(255,255,255,0.14),rgba(255,255,255,0.06));border-radius:8px;}
    input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;width:22px;height:22px;border-radius:50%;background:var(--white);box-shadow:0 12px 36px rgba(0,0,0,0.28);margin-top:-7px;}
    .value-badge{min-width:56px;text-align:center;font-weight:800;background:var(--accent);padding:10px;border-radius:12px;font-size:15px;}

    .voice-display{
      padding:16px;border-radius:12px;background: rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.02);min-height:64px;
      display:flex;flex-direction:column;gap:8px;font-weight:700;
    }
    .voice-label{opacity:0.85;font-size:13px;font-weight:800}

    .device-controls{
      display:flex;gap:14px;align-items:center;justify-content:flex-start;
    }
    .btn{background:var(--white);color:var(--bg);border:none;padding:12px 20px;border-radius:14px;cursor:pointer;font-weight:800;height:var(--btn-h);box-shadow:0 16px 40px rgba(0,0,0,0.12);font-size:15px;}
    .btn.ghost{background:transparent;color:var(--white);border:1px solid rgba(255,255,255,0.06);}
    .conn-small{font-size:16px;opacity:.9;color:rgba(255,255,255,0.95);text-align:center;margin-bottom:16px;font-weight:600;}

    /* active arrow highlight color */
    .arrow-btn.active { /* kept for legacy, actual change done above */ }

    /* Hide elements based on mode */
    .voice-mode .arrow-btn{ display:none; }
    .button-mode .dot{ display:none; }
    .voice-mode .controller{ grid-template-rows: 1fr; grid-template-columns: 1fr; place-items:center; }

    /* responsive */
    @media (max-width:1200px){
      :root{ --control-size:360px; --arrow-size:90px; --center-size:140px; --gap:28px; }
      .panel-right{width:440px;}
    }

    /* Mobile-specific reflow: stack panels and arrange order to match requested mobile structure */
    @media (max-width:900px){
      .app{flex-direction:column;padding:18px;}
      .panel-left{min-width:unset;}
      .panel-right{width:100%;}

      /* Make panel-right appear first, controller second on mobile */
      .panel-right{order:1;}
      .panel-left{order:2;display:flex;justify-content:center;}

      :root{ --control-size:320px; --arrow-size:82px; --center-size:120px; --gap:20px;}

      /* Within right panel, reorder items: device-controls first, then status, then mode selector.
         We can't move .card out of the right panel via CSS across different parent containers,
         so we'll also use a small JS reflow to move the .card under the controller element on mobile
         for the final order: connect/disconnect -> status -> modes -> controller -> card (slider + recognized text). */
      .panel-right .device-controls{order:1;}
      .panel-right .conn-small{order:2;}
      .panel-right .control-modes{order:3; margin-bottom:12px;}
      /* keep the card visually present in the right panel when JS fails, but it will be moved by JS to the desired position */
      .panel-right .card{order:4;}
      
      /* Make control modes and conn-small more prominent on mobile */
      .control-modes{justify-content:flex-start; gap:10px; margin-bottom:8px;}
      .mode-btn{padding:10px 16px;font-size:13px;}
      .conn-small{font-size:15px;text-align:left;}

      /* Slightly reduce button sizes on narrow phones */
      .btn{height:48px;padding:10px 16px;font-size:14px;}
      .value-badge{min-width:48px;padding:8px;font-size:13px;}
    }

  </style>
</head>
<body>
  <header class="top-header">
  <img src="logo.png" alt="Robotic Schools Logo" class="logo">
</header>
<div class="wrap">
  <div class="app" role="application" aria-label="Microbit Controller">
    <div class="panel-left">
      <div class="controller" id="controller">
        <div class="arrow-btn up" data-dir="forward" id="btn-up" title="Forward" role="button" tabindex="0" aria-pressed="false">
          <svg class="arrow-icon" viewBox="0 0 24 24"><path d="M12 4l-8 8h6v8h4v-8h6z"/></svg>
        </div>

        <div class="arrow-btn left" data-dir="left" id="btn-left" title="Left" role="button" tabindex="0" aria-pressed="false">
          <svg class="arrow-icon" viewBox="0 0 24 24"><path d="M6 12l8-8v6h8v4h-8v6z"/></svg>
        </div>

        <div class="dot" id="voiceBtn" title="Press and hold to speak" role="button" tabindex="0" aria-pressed="false" aria-label="Voice input">
          <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12 14a3 3 0 0 0 3-3V7a3 3 0 1 0-6 0v4a3 3 0 0 0 3 3zm5-3a5 5 0 0 1-10 0H5a7 7 0 0 0 6 6.92V21h2v-3.08A7 7 0 0 0 19 11h-2z"/></svg>
        </div>

        <div class="arrow-btn right" data-dir="right" id="btn-right" title="Right" role="button" tabindex="0" aria-pressed="false">
          <svg class="arrow-icon" viewBox="0 0 24 24"><path d="M18 12l-8 8v-6H2v-4h8V4z"/></svg>
        </div>

        <div class="arrow-btn down" data-dir="backward" id="btn-down" title="Backward" role="button" tabindex="0" aria-pressed="false">
          <svg class="arrow-icon" viewBox="0 0 24 24"><path d="M12 20l8-8h-6V4h-4v8H4z"/></svg>
        </div>

        <div class="ripple" id="ripple"></div>
      </div>
    </div>

    <div class="panel-right">
      <div class="control-modes">
        <button class="mode-btn active" id="buttonModeBtn">Button Control</button>
        <button class="mode-btn" id="voiceModeBtn">Voice Control</button>
      </div>
      
      <div class="conn-small" id="connSmall">Not connected</div>

      <div class="card" id="card-main">
        <div class="slider-row" aria-hidden="false">
          <div class="slider-label">SPEED</div>
          <input id="slider1" type="range" min="0" max="100" value="50" aria-label="Speed control">
          <div id="v1" class="value-badge">50</div>
        </div>

        <div class="voice-display" id="voiceDisplay">
          <div>
            <div class="voice-label">Recognized</div>
            <div id="voiceText" style="margin-top:6px;font-size:16px;opacity:.98">â€”</div>
          </div>
        </div>

        <div class="device-controls">
          <button id="connectBtn" class="btn">Connect</button>
          <button id="disconnectBtn" class="btn ghost">Disconnect</button>
          <div style="flex:1"></div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
/* Integrated BLE + Controls
   - Mobile reflow: On small viewports we move the .card below the controller so the visual
     DOM order becomes:
       Connect / Disconnect -> Status -> Modes -> Controller -> Slider -> Recognized Text
   - Desktop behavior unchanged.
*/

// ---------- UI helpers ----------
const connSmall = document.getElementById('connSmall');
const connectBtn = document.getElementById('connectBtn');
const disconnectBtn = document.getElementById('disconnectBtn');
const slider1 = document.getElementById('slider1');
const v1 = document.getElementById('v1');
const voiceTextEl = document.getElementById('voiceText');
const voiceBtn = document.getElementById('voiceBtn');
const ripple = document.getElementById('ripple');
const controller = document.getElementById('controller');
const cardMain = document.getElementById('card-main');
const panelLeft = document.querySelector('.panel-left');
const panelRight = document.querySelector('.panel-right');

function setConnText(t, color){
  connSmall.textContent = t;
  connSmall.style.color = color || 'white';
}

// ---------- control mode switching (keeps original behaviour) ----------
let currentMode = 'button';
const buttonModeBtn = document.getElementById('buttonModeBtn');
const voiceModeBtn = document.getElementById('voiceModeBtn');
function switchMode(mode) {
  currentMode = mode;
  buttonModeBtn.classList.toggle('active', mode === 'button');
  voiceModeBtn.classList.toggle('active', mode === 'voice');
  controller.className = 'controller';
  if (mode === 'voice') controller.classList.add('voice-mode'); else controller.classList.add('button-mode');
  document.querySelectorAll('.arrow-btn').forEach(btn => btn.classList.remove('active','pressed'));
  voiceBtn.classList.remove('listening');
  voiceTextEl.textContent = 'â€”';
}
buttonModeBtn.addEventListener('click', () => switchMode('button'));
voiceModeBtn.addEventListener('click', () => switchMode('voice'));
switchMode('button');

// ---------- ripple ----------
function animateRipple(){
  const size = Math.max(160, window.innerWidth * 0.08);
  ripple.style.width = ripple.style.height = size + 'px';
  ripple.style.left = `calc(50% - ${size/2}px)`;
  ripple.style.top = `calc(50% - ${size/2}px)`;
  ripple.animate(
    [{transform:'scale(0)', opacity:0.28},{transform:'scale(1.08)', opacity:0.12},{transform:'scale(1.6)', opacity:0}],
    {duration:520, easing:'cubic-bezier(.2,.9,.3,1)'}
  );
}

// ---------- speed slider ----------
let sBusy = false;
slider1.addEventListener('input', (e) => {
  // convert range 0â€“100 â†’ 0â€“255
  const scaledValue = Math.round((e.target.value / 100) * 255);
  v1.textContent = scaledValue;
  if (sBusy) return;
  sBusy = true;
  // send with prefix "speed"
  sendUART(`speed${scaledValue}`);
  setTimeout(() => sBusy = false, 140);
});

// ---------- Arrow/button behaviour ----------
const arrowButtons = document.querySelectorAll('.arrow-btn');
arrowButtonsSetup();
function arrowButtonsSetup(){
  arrowButtons.forEach(btn=>{
    const dir = btn.dataset.dir;
    const press = (ev)=>{
      ev.preventDefault();
      if(currentMode !== 'button') return;
      btn.classList.add('pressed','active');
      sendUART(dir);
    };
    const release = (ev)=>{
      ev.preventDefault();
      if(currentMode !== 'button') return;
      btn.classList.remove('pressed');
      setTimeout(()=> btn.classList.remove('active'), 180);
      sendUART('stop');
    };
    btn.addEventListener('mousedown', press);
    btn.addEventListener('touchstart', press, {passive:true});
    btn.addEventListener('mouseup', release);
    btn.addEventListener('mouseleave', release);
    btn.addEventListener('touchend', release);
    btn.addEventListener('keydown', (e)=>{ if(e.key === ' ' || e.key === 'Enter'){ press(e); }});
    btn.addEventListener('keyup', (e)=>{ if(e.key === ' ' || e.key === 'Enter'){ release(e); }});
  });
}

// ---------- Voice recognition (continuous with robust auto-restart) ----------
const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition || null;
let recognizer = null;
let isListening = false;
let silenceTimer = null;
let restartBackoff = 250; // ms, grows on repeated errors up to a cap
const RESTART_BACKOFF_MAX = 2000; // ms
const SILENCE_MS = 6000; // restart if no speech result for this long

function clearSilenceTimer(){
  if (silenceTimer) { clearTimeout(silenceTimer); silenceTimer = null; }
}
function armSilenceTimer(){
  clearSilenceTimer();
  silenceTimer = setTimeout(() => {
    if (!isListening || !recognizer) return;
    try {
      recognizer.abort();
    } catch(e) { /* ignore */ }
  }, SILENCE_MS);
}

function createRecognizer() {
  if (!SpeechRecognition) return null;
  const r = new SpeechRecognition();
  r.lang = 'en-US';
  r.interimResults = true;
  r.maxAlternatives = 1;
  r.continuous = true;

  r.onresult = (e) => {
    let transcript = '';
    for (let i = e.resultIndex; i < e.results.length; i++) {
      const t = (e.results[i][0]?.transcript || '').trim();
      if (t) transcript = t;
    }
    if (!transcript) return;

    voiceTextEl.textContent = transcript;

    const mapped = mapVoiceToCommand(transcript);
    if (mapped) {
      sendUART(mapped);
      highlightArrowForCommand(mapped);
    }

    if (/\bsend\b/i.test(transcript)) {
      const cleaned = transcript.replace(/\bsend\b/gi, '').trim();
      sendUART(cleaned || transcript);
    }

    armSilenceTimer();
  };

  r.onend = () => {
    if (isListening) {
      setTimeout(() => {
        try { r.start(); } catch(e) { /* will be handled in onerror path */ }
      }, restartBackoff);
      restartBackoff = Math.min(restartBackoff * 1.5, RESTART_BACKOFF_MAX);
    } else {
      voiceBtn.classList.remove('listening');
      setConnText('Voice: Stopped', 'white');
      clearSilenceTimer();
    }
  };

  r.onerror = (err) => {
    console.warn('Speech error', err);
    if (!isListening) return;
    if (err.error === 'no-speech' || err.error === 'aborted' || err.error === 'network') {
      try { r.abort(); } catch(e) {}
      setTimeout(() => {
        try { r.start(); } catch(e) { /* let onend handle retries */ }
      }, restartBackoff);
      restartBackoff = Math.min(restartBackoff * 1.5, RESTART_BACKOFF_MAX);
      return;
    }
    isListening = false;
    voiceBtn.classList.remove('listening');
    setConnText('Voice: Error', 'salmon');
    clearSilenceTimer();
  };

  return r;
}

async function warmUpMic() {
  if (!navigator.mediaDevices?.getUserMedia) return;
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    stream.getTracks().forEach(t => t.stop());
  } catch (e) {
    console.warn('Mic warmup failed', e);
  }
}

async function startListening() {
  if (!SpeechRecognition) {
    alert('Speech recognition not supported in this browser.');
    return;
  }
  if (isListening) return;

  await warmUpMic();
  if (!recognizer) recognizer = createRecognizer();
  if (!recognizer) return;

  try {
    restartBackoff = 250;
    recognizer.start();
    isListening = true;
    voiceBtn.classList.add('listening');
    setConnText('Voice: Listening (click to stop)', '#b5f27d');
    armSilenceTimer();
  } catch (e) {
    console.warn('recognizer start error', e);
    isListening = false;
    voiceBtn.classList.remove('listening');
    setConnText('Voice: Failed to start', 'salmon');
  }
}

function stopListening() {
  if (!recognizer) return;
  try {
    isListening = false;
    recognizer.stop();
  } catch (e) {
    console.warn('error stopping recognizer', e);
    isListening = false;
  }
  voiceBtn.classList.remove('listening');
  setConnText('Voice: Stopped', 'white');
  clearSilenceTimer();
}

// Toggle on click/keyboard
voiceBtn.addEventListener('click', (e) => {
  e.preventDefault();
  if (currentMode !== 'voice') return;
  if (!isListening) startListening();
  else stopListening();
});
voiceBtn.addEventListener('keydown', (e) => {
  if (e.key === ' ' || e.key === 'Enter') {
    e.preventDefault();
    voiceBtn.click();
  }
});

// ---------- Keyboard handling ----------
var up_state = false; var down_state = false; var left_state = false; var right_state = false; var z_state = false; var x_state = false; var space_state = false;

document.addEventListener("keydown", keyDownHandler, false);
document.addEventListener("keyup", keyUpHandler, false);

function keyDownHandler(event){
  var keyPressed = String.fromCharCode(event.keyCode);
  if (keyPressed == "&") { sendUART("up"); up_state = true; }
  if (keyPressed == "(") { down_state = true; sendUART("down"); }
  if (keyPressed == "%") { left_state = true; sendUART("left"); }
  if (keyPressed == "'") { right_state = true; sendUART("right"); }
  if (keyPressed == " ") { space_state = true; }
  if (keyPressed == "Z") { z_state = true; sendUART("z"); }
  if (keyPressed == "X") { x_state = true; sendUART("x"); }
}

function keyUpHandler(event){
  var keyPressed = String.fromCharCode(event.keyCode);
  if (keyPressed == "&") { up_state = false; sendUART("stop"); }
  if (keyPressed == "(") { down_state = false; sendUART("stop"); }
  if (keyPressed == "%") { left_state = false; sendUART("stop"); }
  if (keyPressed == "'") { right_state = false; sendUART("stop"); }
  if (keyPressed == " ") { space_state = false; sendUART("stop"); }
  if (keyPressed == "Z") { z_state = false; sendUART("stop"); }
  if (keyPressed == "X") { x_state = false; sendUART("stop"); }
}

// ---------- BLE (UART NUS) ----------
const UART_SERVICE_UUID = '6e400001-b5a3-f393-e0a9-e50e24dcca9e';
const UART_NOTIFY_CHAR_UUID = '6e400002-b5a3-f393-e0a9-e50e24dcca9e'; // device -> browser (notify)
const UART_WRITE_CHAR_UUID  = '6e400003-b5a3-f393-e0a9-e50e24dcca9e'; // browser -> device (write)

let uBitDevice = null;
let notifyCharacteristic = null; // tx from device
let writeCharacteristic = null;  // rx on device (we write here)

// Simple operation queue to avoid concurrent writes
let queue = Promise.resolve();
function queueGattOperation(operation) { queue = queue.then(operation, operation); return queue; }

function showCharInfo(char, name){ if(!char) return console.log(name + ': null'); console.log(`${name} properties:`, { broadcast: char.properties.broadcast, read: char.properties.read, write: char.properties.write, writeWithoutResponse: char.properties.writeWithoutResponse, notify: char.properties.notify, indicate: char.properties.indicate }); }

async function connectButtonPressed(){
  try{
    setConnText('Pairing...', 'yellow');
    uBitDevice = await navigator.bluetooth.requestDevice({
      filters: [{ namePrefix: 'BBC micro:bit' }],
      optionalServices: [UART_SERVICE_UUID]
    });
    uBitDevice.addEventListener('gattserverdisconnected', onDisconnected);

    setConnText('Connecting...', 'yellow');
    const server = await uBitDevice.gatt.connect();

    setConnText('Getting service...', 'yellow');
    const service = await server.getPrimaryService(UART_SERVICE_UUID);

    setConnText('Getting characteristics...', 'yellow');
    // get notify (device -> browser)
    notifyCharacteristic = await service.getCharacteristic(UART_NOTIFY_CHAR_UUID);
    showCharInfo(notifyCharacteristic, 'notifyChar (6e400002)');
    if(notifyCharacteristic.properties.notify || notifyCharacteristic.properties.indicate){
      await notifyCharacteristic.startNotifications();
      notifyCharacteristic.addEventListener('characteristicvaluechanged', onNotifyValueChanged);
    } else {
      console.warn('notifyChar does not support notifications.');
    }

    // get write characteristic (browser -> device)
    writeCharacteristic = await service.getCharacteristic(UART_WRITE_CHAR_UUID);
    showCharInfo(writeCharacteristic, 'writeChar (6e400003)');

    setConnText('Connected: ' + (uBitDevice.name || 'Micro:Bit'), '#b5f27d');
    document.getElementById('connectBtn').textContent = 'Connected';
    document.getElementById('connectBtn').disabled = true;
    document.getElementById('robotShow') && document.getElementById('robotShow').classList && document.getElementById('robotShow').classList.add('robotShow_connected');
  }catch(err){
    console.warn('Connect failed', err);
    setConnText('Connection failed - Make sure Micro:Bit is on and nearby', 'salmon');
  }
}

function disconnectButtonPressed(){
  if(!uBitDevice) return;
  if(uBitDevice.gatt.connected){ uBitDevice.gatt.disconnect(); setConnText('Disconnected', 'white'); }
  else setConnText('Not connected', 'white');
}

function onDisconnected(event){
  let device = event.target;
  console.log(`Device ${device.name} is disconnected.`);
  setConnText('Disconnected', 'white');
  document.getElementById('connectBtn').textContent = 'Connect';
  document.getElementById('connectBtn').disabled = false;
  document.getElementById('robotShow') && document.getElementById('robotShow').classList && document.getElementById('robotShow').classList.remove('robotShow_connected');
}

function onNotifyValueChanged(event){
  const value = event.target.value;
  const decoder = new TextDecoder();
  const text = decoder.decode(value);
  console.log('Received from device:', text);
  if(text.trim() === 'S') console.log('Shaken!');
}

// sendUART: writes to writeCharacteristic (6e400003)
async function sendUART(payload){
  if(!writeCharacteristic){ setConnText('Not connected - Click Connect first', 'salmon'); return; }
  const encoder = new TextEncoder();
  const data = encoder.encode(payload + '\n');

  queueGattOperation(() => (async () => {
    try{
      if(writeCharacteristic.properties.write){
        await writeCharacteristic.writeValue(data);
      } else if(writeCharacteristic.properties.writeWithoutResponse){
        try{ await writeCharacteristic.writeValue(data); }
        catch(e){ if(typeof writeCharacteristic.writeValueWithoutResponse === 'function'){ await writeCharacteristic.writeValueWithoutResponse(data); } else throw e; }
      } else {
        throw new Error('Characteristic not writable');
      }
      console.log('Sent:', payload);
    }catch(err){ console.error('Write error', err); setConnText('Send failed - Check Micro:Bit connection', 'salmon'); }
  })());
}

// Attach connect/disconnect buttons
connectBtn.addEventListener('click', connectButtonPressed);
disconnectBtn.addEventListener('click', disconnectButtonPressed);

// ---------- small utilities ----------
function valBetween(v, min, max) { return (Math.min(max, Math.max(min, v))); }

function allStop(){ sendUART('STOP'); }

function highlightArrowForCommand(cmd){
  const mapping = { 'forward':'btn-up', 'backward':'btn-down', 'left':'btn-left', 'right':'btn-right', 'stop':'btn-down' };
  const id = mapping[cmd];
  if(!id) return;
  const el = document.getElementById(id);
  if(!el) return;
  el.classList.add('active');
  setTimeout(()=> el.classList.remove('active'), 360);
}

function mapVoiceToCommand(text){
  const t = text.toLowerCase();
  if(t.match(/\b(forward|ahead|up)\b/)) return 'forward';
  if(t.match(/\b(back|backward|reverse|down)\b/)) return 'backward';
  if(t.match(/\bleft\b/)) return 'left';
  if(t.match(/\bright\b/)) return 'right';
  if(t.match(/\bstop\b/)) return 'stop';
  return null;
}

/* ---------- Mobile reflow logic ----------
   On small screens we want:
     1) Connect buttons
     2) Status label
     3) Mode switch
     4) Controller (arrows / mic depending on mode)
     5) Speed slider
     6) Recognized text

   We achieve this by:
   - Using CSS to stack panels (panel-right first, controller second).
   - Moving the .card element (slider + recognized text + device-controls) below the controller in the DOM when width < 900.
*/
function reflowForMobile() {
  const mobile = window.matchMedia('(max-width:900px)').matches;

  if (mobile) {
    // move card after controller if not already moved
    if (cardMain.parentElement !== panelLeft) {
      // detach then insert after controller container
      const afterNode = controller.parentElement; // panel-left
      // Insert card after the panel-left element in the .app flow so it appears below controller
      panelLeft.insertAdjacentElement('afterend', cardMain);
    }
  } else {
    // move card back into panel-right if necessary
    if (cardMain.parentElement !== panelRight) {
      panelRight.appendChild(cardMain);
    }
  }
}

// run on load and resize
window.addEventListener('load', reflowForMobile);
window.addEventListener('resize', () => {
  // debounce small resizes
  clearTimeout(window._reflowTO);
  window._reflowTO = setTimeout(reflowForMobile, 120);
});

// ensure initial class state for modes
reflowForMobile();

</script>
</body>
</html>
